#include "qemu/osdep.h"
#include "hw/pci/pci.h"
#include "hw/pci/pci_device.h"
#include "hw/qdev-properties.h"
#include "qemu/log.h"
#include "qemu/module.h"
#include "qemu/timer.h"
#include "qapi/error.h"
#include "hw/pci/msix.h"
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/videodev2.h>

#define TYPE_CSI2_V4L2_LOOPBACK_PCIE "mipi-csi-camera-v4l2"
OBJECT_DECLARE_SIMPLE_TYPE(CSI2V4L2LoopbackPCIe, CSI2_V4L2_LOOPBACK_PCIE)

#define CSI2_VENDOR_ID    0x1234
#define CSI2_DEVICE_ID    0x5679
#define CSI2_MSIX_VECTORS 4

typedef struct CSI2V4L2LoopbackPCIe {
    PCIDevice parent_obj;
    MemoryRegion mmio;
    QEMUTimer *frame_timer;
    
    /* CSI2 simulation state */
    uint32_t core_config;
    uint32_t core_status;
    uint32_t sequence_number;
    uint32_t frames_captured;
    bool streaming_active;
    
    /* V4L2 loopback state */
    int v4l2_fd;
    char *v4l2_device_path;
    bool v4l2_initialized;
    
    /* Frame data */
    uint8_t *frame_buffer;
    size_t frame_buffer_size;
    uint32_t frame_width;
    uint32_t frame_height;
    uint32_t fps;
    
    /* Device state */
    bool initialized;
    bool msix_enabled;
    uint32_t interrupt_count;
    bool timer_running;
} CSI2V4L2LoopbackPCIe;

// Find available V4L2 loopback device
static char *find_v4l2_loopback_device(void)
{
    for (int i = 4; i < 16; i++) {  // Start from video4 to avoid system cameras
        char device_path[64];
        snprintf(device_path, sizeof(device_path), "/dev/video%d", i);
        
        // Check if device exists
        if (access(device_path, F_OK) == 0) {
            int fd = open(device_path, O_RDWR | O_NONBLOCK);
            if (fd >= 0) {
                struct v4l2_capability cap;
                if (ioctl(fd, VIDIOC_QUERYCAP, &cap) == 0) {
                    if (strstr((char*)cap.driver, "v4l2 loopback") ||
                        strstr((char*)cap.card, "Dummy video device")) {
                        close(fd);
                        printf("CSI2-V4L2: Found loopback device: %s (%s)\n", 
                               device_path, cap.card);
                        return g_strdup(device_path);
                    }
                }
                close(fd);
            }
        }
    }
    
    printf("CSI2-V4L2: No v4l2loopback device found\n");
    return NULL;
}

// Initialize V4L2 loopback device
static int csi2_init_v4l2_loopback(CSI2V4L2LoopbackPCIe *dev)
{
    struct v4l2_format fmt;
    
    // Find V4L2 loopback device
    dev->v4l2_device_path = find_v4l2_loopback_device();
    if (!dev->v4l2_device_path) {
        return -1;
    }
    
    // Open V4L2 device
    dev->v4l2_fd = open(dev->v4l2_device_path, O_RDWR | O_NONBLOCK);
    if (dev->v4l2_fd < 0) {
        printf("CSI2-V4L2: Failed to open %s: %s\n", 
               dev->v4l2_device_path, strerror(errno));
        g_free(dev->v4l2_device_path);
        dev->v4l2_device_path = NULL;
        return -1;
    }
    
    // Set format
    memset(&fmt, 0, sizeof(fmt));
    fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
    fmt.fmt.pix.width = dev->frame_width;
    fmt.fmt.pix.height = dev->frame_height;
    fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_RGB24;
    fmt.fmt.pix.field = V4L2_FIELD_NONE;
    fmt.fmt.pix.bytesperline = dev->frame_width * 3;
    fmt.fmt.pix.sizeimage = dev->frame_width * dev->frame_height * 3;
    fmt.fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
    
    if (ioctl(dev->v4l2_fd, VIDIOC_S_FMT, &fmt) < 0) {
        printf("CSI2-V4L2: Failed to set format: %s\n", strerror(errno));
        close(dev->v4l2_fd);
        dev->v4l2_fd = -1;
        g_free(dev->v4l2_device_path);
        dev->v4l2_device_path = NULL;
        return -1;
    }
    
    printf("CSI2-V4L2: V4L2 format set: %dx%d RGB24 on %s\n", 
           fmt.fmt.pix.width, fmt.fmt.pix.height, dev->v4l2_device_path);
    
    dev->v4l2_initialized = true;
    return 0;
}

// Generate and write test frame
static void csi2_generate_and_write_frame(CSI2V4L2LoopbackPCIe *dev)
{
    if (!dev->frame_buffer || !dev->v4l2_initialized || dev->v4l2_fd < 0) {
        return;
    }
    
    uint8_t *buf = dev->frame_buffer;
    uint32_t frame_counter = dev->sequence_number % 256;
    
    // Generate simple test pattern
    for (uint32_t y = 0; y < dev->frame_height; y++) {
        for (uint32_t x = 0; x < dev->frame_width; x++) {
            uint32_t offset = (y * dev->frame_width + x) * 3;
            buf[offset + 0] = (x + frame_counter) % 256;        // R
            buf[offset + 1] = (y + frame_counter) % 256;        // G
            buf[offset + 2] = (x + y + frame_counter) % 256;    // B
        }
    }
    
    // Write to V4L2 loopback device
    ssize_t written = write(dev->v4l2_fd, dev->frame_buffer, dev->frame_buffer_size);
    if (written == (ssize_t)dev->frame_buffer_size) {
        dev->frames_captured++;
        if (dev->frames_captured % 30 == 1) {
            printf("CSI2-V4L2: Wrote frame %d to %s\n", 
                   dev->frames_captured, dev->v4l2_device_path);
        }
    }
}

// Frame timer callback
static void csi2_frame_timer_cb(void *opaque)
{
    CSI2V4L2LoopbackPCIe *dev = CSI2_V4L2_LOOPBACK_PCIE(opaque);
    
    if (!dev->timer_running || !dev->streaming_active) {
        return;
    }
    
    dev->interrupt_count++;
    dev->sequence_number++;
    dev->frames_captured++;
    
    // Update core status
    dev->core_status = (dev->sequence_number << 16) & 0xFFFF0000;
    
    // Generate and write frame to V4L2 loopback
    csi2_generate_and_write_frame(dev);
    
    // Send MSI-X interrupt
    if (dev->msix_enabled && msix_enabled(&dev->parent_obj)) {
        msix_notify(&dev->parent_obj, 0);  // Use vector 0
        
        if (dev->interrupt_count % 30 == 1) {
            printf("CSI2-V4L2: MSI-X frame interrupt sent (count: %d)\n", 
                   dev->interrupt_count);
        }
    }
    
    // Schedule next frame
    uint64_t frame_interval_ns = 1000000000ULL / dev->fps;
    timer_mod(dev->frame_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + frame_interval_ns);
}

// MMIO read handler
static uint64_t csi2_mmio_read(void *opaque, hwaddr addr, unsigned size)
{
    CSI2V4L2LoopbackPCIe *dev = CSI2_V4L2_LOOPBACK_PCIE(opaque);
    
    switch (addr) {
    case 0x00: /* Magic number */
        return 0xDEADBEEF;
    case 0x04: /* Core config */
        return dev->core_config;
    case 0x08: /* Core status */
        return dev->core_status;
    case 0x0C: /* Initialized flag */
        return dev->initialized ? 1 : 0;
    case 0x10: /* MSI-X enabled */
        return dev->msix_enabled ? 1 : 0;
    case 0x14: /* Interrupt count */
        return dev->interrupt_count;
    case 0x18: /* Timer running */
        return dev->streaming_active ? 1 : 0; //return dev->timer_running ? 1 : 0;
    case 0x1C: /* MSI-X present */
        return msix_present(&dev->parent_obj) ? 1 : 0;
    case 0x20: /* Streaming active */
        return dev->streaming_active ? 1 : 0;
    case 0x24: /* Sequence number */
        return dev->sequence_number;
    case 0x28: /* Frames captured */
        return dev->frames_captured;
    case 0x2C: /* V4L2 initialized */
        return dev->v4l2_initialized ? 1 : 0;
    case 0x30: /* Frame config */
        return (dev->frame_width << 16) | dev->frame_height;
    case 0x34: /* FPS */
        return dev->fps;
    default:
        return 0;
    }
}

// MMIO write handler
static void csi2_mmio_write(void *opaque, hwaddr addr, uint64_t value, unsigned size)
{
    CSI2V4L2LoopbackPCIe *dev = CSI2_V4L2_LOOPBACK_PCIE(opaque);
    
    switch (addr) {
    case 0x04: /* Core config */
        dev->core_config = value & 0x7;
        printf("CSI2-V4L2: Core config written: 0x%lx\n", value);
        break;
    case 0x14: /* Interrupt counter reset */
        if (value == 0) {
            dev->interrupt_count = 0;
            printf("CSI2-V4L2: Interrupt counter reset\n");
        }
        break;
    case 0x18: /* Timer control */
        if (value & 1) {
            if (!dev->timer_running) {
                dev->timer_running = true;
                dev->streaming_active = true;
                dev->sequence_number = 0;
                dev->frames_captured = 0;
                timer_mod(dev->frame_timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 33333333);
                printf("CSI2-V4L2: Streaming started (%dx%d @ %d fps)\n", 
                       dev->frame_width, dev->frame_height, dev->fps);
            }
        } else {
            if (dev->timer_running) {
                dev->timer_running = false;
                dev->streaming_active = false;
                timer_del(dev->frame_timer);
                printf("CSI2-V4L2: Streaming stopped\n");
            }
        }
        break;
    case 0x1C: /* Manual MSI-X interrupt test */
        if (value == 0xDEADBEEF) {
		dev->interrupt_count++;
		if(dev->msix_enabled && msix_enabled(&dev->parent_obj)) {
			msix_notify(&dev->parent_obj, 1);  // Use vector 1 for test
		        printf("CSI2-V4L2: Manual MSI-X interrupt sent (count: %d)\n", dev->interrupt_count);
		} else {
			printf("CSI2-V4L2: Manual interrupt triggered (count: %d)\n", dev->interrupt_count);
		}
        }
        break;
    case 0x24: /* Sequence number reset */
        if (value == 0) {
            dev->sequence_number = 0;
            printf("CSI2-V4L2: Sequence number reset\n");
        }
        break;
    case 0x28: /* Frames captured reset */
        if (value == 0) {
            dev->frames_captured = 0;
            printf("CSI2-V4L2: Frames captured reset\n");
        }
        break;
    default:
        break;
    }
}

static const MemoryRegionOps csi2_mmio_ops = {
    .read = csi2_mmio_read,
    .write = csi2_mmio_write,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

// Device realization
static void csi2_pcie_realize(PCIDevice *pci_dev, Error **errp)
{
    CSI2V4L2LoopbackPCIe *dev = CSI2_V4L2_LOOPBACK_PCIE(pci_dev);
    Error *local_err = NULL;
    int ret;
    
    printf("CSI2-V4L2: Device initialization started\n");
    
    /* Basic PCI setup */
    pci_config_set_interrupt_pin(pci_dev->config, 1);
    
    /* MMIO region setup (4KB) */
    memory_region_init_io(&dev->mmio, OBJECT(dev), &csi2_mmio_ops, dev, 
                          "csi2-v4l2-mmio", 0x1000);
    pci_register_bar(pci_dev, 0, PCI_BASE_ADDRESS_MEM_TYPE_32, &dev->mmio);
    printf("CSI2-V4L2: BAR 0 registered (4KB MMIO)\n");
    
    /* MSI-X initialization attempt */
    ret = msix_init_exclusive_bar(pci_dev, CSI2_MSIX_VECTORS, 1, &local_err);
    if (ret < 0) {
        printf("CSI2-V4L2: MSI-X initialization failed: %d, using legacy interrupts\n", ret);
        if (local_err) {
            error_free(local_err);
        }
        dev->msix_enabled = false;
    } else {
        printf("CSI2-V4L2: MSI-X initialized successfully (%d vectors, BAR 1)\n", CSI2_MSIX_VECTORS);
        dev->msix_enabled = true;
    }
    
    /* Frame timer creation */
    dev->frame_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, csi2_frame_timer_cb, dev);
    if (!dev->frame_timer) {
        error_setg(errp, "CSI2-V4L2: Failed to create frame timer");
        goto cleanup;
    }
    printf("CSI2-V4L2: Frame timer created\n");
    
    /* Frame configuration */
    dev->frame_width = 1280;
    dev->frame_height = 720;
    dev->fps = 30;
    dev->frame_buffer_size = dev->frame_width * dev->frame_height * 3;  // RGB24
    
    /* Allocate frame buffer */
    dev->frame_buffer = g_malloc(dev->frame_buffer_size);
    if (!dev->frame_buffer) {
        error_setg(errp, "CSI2-V4L2: Failed to allocate frame buffer");
        goto cleanup;
    }
    printf("CSI2-V4L2: Frame buffer allocated (%zu bytes)\n", dev->frame_buffer_size);
    
    /* Initialize V4L2 loopback */
    dev->v4l2_fd = -1;
    dev->v4l2_device_path = NULL;
    dev->v4l2_initialized = false;
    
    if (csi2_init_v4l2_loopback(dev) == 0) {
        printf("CSI2-V4L2: V4L2 loopback initialized successfully\n");
    } else {
        printf("CSI2-V4L2: V4L2 loopback initialization failed, running in CSI2-only mode\n");
    }
    
    /* Initialize device state */
    dev->core_config = 1;  // Enabled by default
    dev->core_status = 0;
    dev->sequence_number = 0;
    dev->frames_captured = 0;
    dev->streaming_active = false;
    dev->initialized = true;
    dev->interrupt_count = 0;
    dev->timer_running = false;
    
    printf("CSI2-V4L2: Device initialized successfully\n");
    printf("CSI2-V4L2: MSI-X: %s, Legacy IRQ: Pin A\n", 
           dev->msix_enabled ? "Available" : "Not available");
    printf("CSI2-V4L2: V4L2 loopback: %s\n",
           dev->v4l2_initialized ? dev->v4l2_device_path : "Not available");
    printf("CSI2-V4L2: Register Map:\n");
    printf("  0x00: Magic (0xDEADBEEF)\n");
    printf("  0x04: Core config (R/W)\n");
    printf("  0x08: Core status (R)\n");
    printf("  0x14: Interrupt count (R/W - write 0 to reset)\n");
    printf("  0x18: Streaming control (R/W - write 1 to start, 0 to stop)\n");
    printf("  0x1C: Manual interrupt (W - write 0xDEADBEEF to trigger)\n");
    printf("  0x20: Streaming active (R)\n");
    printf("  0x24: Sequence number (R/W - write 0 to reset)\n");
    printf("  0x28: Frames captured (R/W - write 0 to reset)\n");
    printf("  0x30: Frame config (R - width<<16 | height)\n");
    
    return;

cleanup:
    if (dev->msix_enabled && msix_present(pci_dev)) {
        msix_uninit_exclusive_bar(pci_dev);
        dev->msix_enabled = false;
    }
    if (dev->frame_buffer) {
        g_free(dev->frame_buffer);
        dev->frame_buffer = NULL;
    }
}

// Device cleanup
static void csi2_pcie_exit(PCIDevice *pci_dev)
{
    CSI2V4L2LoopbackPCIe *dev = CSI2_V4L2_LOOPBACK_PCIE(pci_dev);
    
    printf("CSI2-V4L2: Device cleanup started\n");
    
    dev->timer_running = false;
    dev->streaming_active = false;
    
    if (dev->frame_timer) {
        timer_del(dev->frame_timer);
        timer_free(dev->frame_timer);
        dev->frame_timer = NULL;
    }
    
    if (dev->v4l2_fd >= 0) {
        close(dev->v4l2_fd);
        dev->v4l2_fd = -1;
    }
    g_free(dev->v4l2_device_path);
    dev->v4l2_device_path = NULL;
    
    if (dev->frame_buffer) {
        g_free(dev->frame_buffer);
        dev->frame_buffer = NULL;
    }
    
    if (dev->msix_enabled && msix_present(pci_dev)) {
        msix_uninit_exclusive_bar(pci_dev);
        dev->msix_enabled = false;
        printf("CSI2-V4L2: MSI-X cleaned up\n");
    }
    
    printf("CSI2-V4L2: Device cleanup completed\n");
}

// Device reset
static void csi2_pcie_reset(DeviceState *qdev)
{
    CSI2V4L2LoopbackPCIe *dev = CSI2_V4L2_LOOPBACK_PCIE(qdev);
    
    if (dev->frame_timer) {
        timer_del(dev->frame_timer);
    }
    
    dev->core_config = 1;
    dev->core_status = 0;
    dev->sequence_number = 0;
    dev->frames_captured = 0;
    dev->interrupt_count = 0;
    dev->timer_running = false;
    dev->streaming_active = false;
    
    printf("CSI2-V4L2: Device reset completed\n");
}

// Device properties
static Property csi2_pcie_properties[] = {
    DEFINE_PROP_UINT32("frame-width", CSI2V4L2LoopbackPCIe, frame_width, 1280),
    DEFINE_PROP_UINT32("frame-height", CSI2V4L2LoopbackPCIe, frame_height, 720),
    DEFINE_PROP_UINT32("fps", CSI2V4L2LoopbackPCIe, fps, 30),
    { }
};

// Class initialization
static void csi2_pcie_class_init(ObjectClass *klass, const void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(klass);
    
    pc->realize = csi2_pcie_realize;
    pc->exit = csi2_pcie_exit;
    pc->vendor_id = CSI2_VENDOR_ID;
    pc->device_id = CSI2_DEVICE_ID;
    pc->class_id = 0x0400;  /* Multimedia controller */
    pc->revision = 0x01;
    
    dc->desc = "MIPI CSI-2 PCIe Device with V4L2 Loopback (Simple)";
    device_class_set_legacy_reset(dc, csi2_pcie_reset);
    dc->props_ = csi2_pcie_properties;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
}

static const TypeInfo csi2_pcie_info = {
    .name = TYPE_CSI2_V4L2_LOOPBACK_PCIE,
    .parent = TYPE_PCI_DEVICE,
    .instance_size = sizeof(CSI2V4L2LoopbackPCIe),
    .class_init = csi2_pcie_class_init,
    .interfaces = (InterfaceInfo[]) {
        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
        { },
    },
};

static void csi2_pcie_register_types(void)
{
    type_register_static(&csi2_pcie_info);
}

type_init(csi2_pcie_register_types)
